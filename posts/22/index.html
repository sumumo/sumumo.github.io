<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mumo.fun","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="绘制基础自定义绘制概述 自定义绘制的方式是重写绘制方法，其中最常用的是 onDraw() 绘制的关键是 Canvas 的使用  Canvas 的绘制类方法：drawXXX ()（关键参数：Paint） Canvas 的辅助类方法：范围裁切和几何变换   可以使用不同的绘制方法来控制遮盖关系">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 自定义 View">
<meta property="og:url" content="https://mumo.fun/posts/22/index.html">
<meta property="og:site_name" content="Mumo">
<meta property="og:description" content="绘制基础自定义绘制概述 自定义绘制的方式是重写绘制方法，其中最常用的是 onDraw() 绘制的关键是 Canvas 的使用  Canvas 的绘制类方法：drawXXX ()（关键参数：Paint） Canvas 的辅助类方法：范围裁切和几何变换   可以使用不同的绘制方法来控制遮盖关系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.mumo.fun/2022/22-5.png">
<meta property="og:image" content="https://img.mumo.fun/2022/22-1.png">
<meta property="og:image" content="https://img.mumo.fun/2022/22-2.jpg">
<meta property="og:image" content="https://img.mumo.fun/2022/22-3.jpg">
<meta property="og:image" content="https://img.mumo.fun/2022/22-4.png">
<meta property="og:image" content="https://img.mumo.fun/2022/22-6.jpg">
<meta property="og:image" content="https://img.mumo.fun/2022/22-7.png">
<meta property="article:published_time" content="2022-08-23T01:59:53.000Z">
<meta property="article:modified_time" content="2022-08-31T00:57:50.715Z">
<meta property="article:author" content="Mumo">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.mumo.fun/2022/22-5.png">


<link rel="canonical" href="https://mumo.fun/posts/22/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://mumo.fun/posts/22/","path":"posts/22/","title":"Android 自定义 View"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android 自定义 View | Mumo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Mumo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">绘制基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">自定义绘制概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6%E7%9F%A5%E8%AF%86%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">自定义绘制知识的四个级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#onDraw"><span class="nav-number">1.3.</span> <span class="nav-text">onDraw()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Canvas-drawXXX-%E5%92%8C-Paint-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.</span> <span class="nav-text">Canvas.drawXXX () 和 Paint 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#drawColor-ColorInt-int-color-%E9%A2%9C%E8%89%B2%E5%A1%AB%E5%85%85"><span class="nav-number">1.4.1.</span> <span class="nav-text">drawColor (@ColorInt int color) 颜色填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawCircle-float-centerX-float-centerY-float-radius-Paint-paint-%E7%94%BB%E5%9C%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">drawCircle (float centerX, float centerY, float radius, Paint paint) 画圆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawRect-float-left-float-top-float-right-float-bottom-Paint-paint-%E7%94%BB%E7%9F%A9%E5%BD%A2"><span class="nav-number">1.4.3.</span> <span class="nav-text">drawRect (float left, float top, float right, float bottom, Paint paint) 画矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawPoint-float-x-float-y-Paint-paint-%E7%94%BB%E7%82%B9"><span class="nav-number">1.4.4.</span> <span class="nav-text">drawPoint (float x, float y, Paint paint) 画点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawPoints-float-pts-int-offset-int-count-Paint-paint-drawPoints-float-pts-Paint-paint-%E7%94%BB%E7%82%B9%EF%BC%88%E6%89%B9%E9%87%8F%EF%BC%89"><span class="nav-number">1.4.5.</span> <span class="nav-text">drawPoints (float [] pts, int offset, int count, Paint paint) &#x2F;drawPoints (float [] pts, Paint paint) 画点（批量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawOval-float-left-float-top-float-right-float-bottom-Paint-paint-%E7%94%BB%E6%A4%AD%E5%9C%86"><span class="nav-number">1.4.6.</span> <span class="nav-text">drawOval (float left, float top, float right, float bottom, Paint paint) 画椭圆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawLine-float-startX-float-startY-float-stopX-float-stopY-Paint-paint-%E7%94%BB%E7%BA%BF"><span class="nav-number">1.4.7.</span> <span class="nav-text">drawLine (float startX, float startY, float stopX, float stopY, Paint paint) 画线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawLines-float-pts-int-offset-int-count-Paint-paint-drawLines-float-pts-Paint-paint-%E7%94%BB%E7%BA%BF%EF%BC%88%E6%89%B9%E9%87%8F%EF%BC%89"><span class="nav-number">1.4.8.</span> <span class="nav-text">drawLines (float [] pts, int offset, int count, Paint paint) &#x2F;drawLines (float [] pts, Paint paint) 画线（批量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawRoundRect-float-left-float-top-float-right-float-bottom-float-rx-float-ry-Paint-paint-%E7%94%BB%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2"><span class="nav-number">1.4.9.</span> <span class="nav-text">drawRoundRect (float left, float top, float right, float bottom, float rx, float ry, Paint paint) 画圆角矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawArc-float-left-float-top-float-right-float-bottom-float-startAngle-float-sweepAngle-boolean-useCenter-Paint-paint-%E7%BB%98%E5%88%B6%E5%BC%A7%E5%BD%A2%E6%88%96%E6%89%87%E5%BD%A2"><span class="nav-number">1.4.10.</span> <span class="nav-text">drawArc (float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 绘制弧形或扇形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawPath-Path-path-Paint-paint-%E7%94%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2"><span class="nav-number">1.4.11.</span> <span class="nav-text">drawPath (Path path, Paint paint) 画自定义图形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%B1%BB%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%8F%8F%E8%BF%B0%E8%B7%AF%E5%BE%84"><span class="nav-number">1.4.11.1.</span> <span class="nav-text">Path 方法第一类：直接描述路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%BB%84%EF%BC%9A-addXxx-%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E5%AD%90%E5%9B%BE%E5%BD%A2"><span class="nav-number">1.4.11.1.1.</span> <span class="nav-text">第一组： addXxx () —— 添加子图形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%BB%84%EF%BC%9AxxxTo-%E2%80%94%E2%80%94%E7%94%BB%E7%BA%BF%EF%BC%88%E7%9B%B4%E7%BA%BF%E6%88%96%E6%9B%B2%E7%BA%BF%EF%BC%89"><span class="nav-number">1.4.11.1.2.</span> <span class="nav-text">第二组：xxxTo () —— 画线（直线或曲线）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Path%E6%96%B9%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%B1%BB%EF%BC%9A%E8%BE%85%E5%8A%A9%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%88%96%E8%AE%A1%E7%AE%97"><span class="nav-number">1.4.11.2.</span> <span class="nav-text">Path 方法第二类：辅助的设置或计算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Path-setFillType-Path-FillType-ft-%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.11.2.1.</span> <span class="nav-text">Path.setFillType (Path.FillType ft) 设置填充方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EVEN-ODD%E5%92%8CWINDING%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.11.2.2.</span> <span class="nav-text">EVEN_ODD 和 WINDING 的原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawBitmap-Bitmap-bitmap-float-left-float-top-Paint-paint-%E7%94%BB-Bitmap"><span class="nav-number">1.4.12.</span> <span class="nav-text">drawBitmap (Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drawText-String-text-float-x-float-y-Paint-paint-%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97"><span class="nav-number">1.4.13.</span> <span class="nav-text">drawText (String text, float x, float y, Paint paint) 绘制文字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Paint%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">Paint 详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#drawText-%E6%96%87%E5%AD%97%E7%9A%84%E7%BB%98%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text"> drawText () 文字的绘制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Canvas%E5%AF%B9%E7%BB%98%E5%88%B6%E7%9A%84%E8%BE%85%E5%8A%A9"><span class="nav-number">4.</span> <span class="nav-text"> Canvas 对绘制的辅助</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">绘制顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#super-onDraw-%E5%89%8Dor%E5%90%8E"><span class="nav-number">5.1.</span> <span class="nav-text">super.onDraw () 前 or 后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-onDraw-%E7%9A%84%E4%B8%8B%E9%9D%A2"><span class="nav-number">5.1.1.</span> <span class="nav-text">写在 super.onDraw () 的下面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-onDraw-%E7%9A%84%E4%B8%8A%E9%9D%A2"><span class="nav-number">5.1.2.</span> <span class="nav-text">写在 super.onDraw () 的上面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatchDraw-%EF%BC%9A%E7%BB%98%E5%88%B6%E5%AD%90View%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">dispatchDraw ()：绘制子 View 的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8-super-dispatchDraw-%E7%9A%84%E4%B8%8B%E9%9D%A2"><span class="nav-number">5.2.1.</span> <span class="nav-text">写在 super.dispatchDraw () 的下面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-dispatchDraw-%E7%9A%84%E4%B8%8A%E9%9D%A2"><span class="nav-number">5.2.2.</span> <span class="nav-text">写在 super.dispatchDraw () 的上面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="nav-number">5.3.</span> <span class="nav-text">绘制过程简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#onDrawForeground-%EF%BC%88API-23%E5%BC%95%E5%85%A5%EF%BC%89"><span class="nav-number">5.4.</span> <span class="nav-text">onDrawForeground ()（API 23 引入）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-onDrawForeground-%E7%9A%84%E4%B8%8B%E9%9D%A2"><span class="nav-number">5.4.1.</span> <span class="nav-text">写在 super.onDrawForeground () 的下面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-onDrawForeground-%E7%9A%84%E4%B8%8A%E9%9D%A2"><span class="nav-number">5.4.2.</span> <span class="nav-text">写在 super.onDrawForeground () 的上面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#draw-%E6%80%BB%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">draw () 总调度方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-draw-%E7%9A%84%E4%B8%8B%E9%9D%A2"><span class="nav-number">5.5.1.</span> <span class="nav-text">写在 super.draw () 的下面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8super-draw-%E7%9A%84%E4%B8%8A%E9%9D%A2"><span class="nav-number">5.5.2.</span> <span class="nav-text">写在 super.draw () 的上面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">5.6.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BBProperty-Animation%E4%B8%8A%E6%89%8B"><span class="nav-number">6.</span> <span class="nav-text">属性动画 Property Animation 上手</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BBProperty-Animation%E8%BF%9B%E9%98%B6"><span class="nav-number">7.</span> <span class="nav-text">属性动画 Property Animation 进阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="nav-number">8.</span> <span class="nav-text">硬件加速</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80"><span class="nav-number">9.</span> <span class="nav-text">布局基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E8%BF%87%E7%A8%8B%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">9.1.</span> <span class="nav-text">布局过程的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E8%BF%87%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9"><span class="nav-number">9.2.</span> <span class="nav-text">布局过程的工作内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View%E6%88%96ViewGroup%E7%9A%84%E5%B8%83%E5%B1%80%E8%BF%87%E7%A8%8B"><span class="nav-number">9.3.</span> <span class="nav-text">View 或 ViewGroup 的布局过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E8%BF%87%E7%A8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">9.4.</span> <span class="nav-text">布局过程自定义的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E6%96%B0%E5%AE%9A%E4%B9%89View%E7%9A%84%E5%B0%BA%E5%AF%B8"><span class="nav-number">10.</span> <span class="nav-text">全新定义 View 的尺寸</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%B0%E5%AE%9A%E5%88%B6%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BF%AE%E6%94%B9%E5%B0%BA%E5%AF%B8%E7%9A%84%E6%9C%80%E9%87%8D%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">10.1.</span> <span class="nav-text">全新定制尺寸和修改尺寸的最重要区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6View%E7%9A%84%E5%B0%BA%E5%AF%B8%E9%99%90%E5%88%B6"><span class="nav-number">10.2.</span> <span class="nav-text">父 View 的尺寸限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%B0%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%B0%BA%E5%AF%B8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">10.3.</span> <span class="nav-text">全新定义自定义 View 尺寸的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6Layout%E7%9A%84%E5%86%85%E9%83%A8%E5%B8%83%E5%B1%80"><span class="nav-number">11.</span> <span class="nav-text">定制 Layout 的内部布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6Layout%E5%86%85%E9%83%A8%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">11.1.</span> <span class="nav-text">定制 Layout 内部布局的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99onMeasure-%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">11.2.</span> <span class="nav-text">重写 onMeasure () 的三个步骤：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%90View%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-number">11.3.</span> <span class="nav-text">计算子 View 尺寸的关键</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90View%E7%9A%84MeasureSpec%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">11.3.1.</span> <span class="nav-text">子 View 的 MeasureSpec 的计算方式：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99onLayout-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">11.4.</span> <span class="nav-text">重写 onLayout() 的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88"><span class="nav-number">12.</span> <span class="nav-text">触摸反馈</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mumo</p>
  <div class="site-description" itemprop="description">也无风雨也无晴</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mumo.fun/posts/22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mumo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mumo">
      <meta itemprop="description" content="也无风雨也无晴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android 自定义 View | Mumo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 自定义 View
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-23 09:59:53" itemprop="dateCreated datePublished" datetime="2022-08-23T09:59:53+08:00">2022-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-31 08:57:50" itemprop="dateModified" datetime="2022-08-31T08:57:50+08:00">2022-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="绘制基础"><a href="#绘制基础" class="headerlink" title="绘制基础"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-1/">绘制基础</a></h1><h2 id="自定义绘制概述"><a href="#自定义绘制概述" class="headerlink" title="自定义绘制概述"></a>自定义绘制概述</h2><ul>
<li>自定义绘制的方式是重写绘制方法，其中最常用的是 <code>onDraw()</code></li>
<li>绘制的关键是 Canvas 的使用<ul>
<li> Canvas 的绘制类方法：drawXXX ()（关键参数：Paint）</li>
<li>Canvas 的辅助类方法：范围裁切和几何变换</li>
</ul>
</li>
<li>可以使用不同的绘制方法来控制遮盖关系</li>
</ul>
<span id="more"></span>

<h2 id="自定义绘制知识的四个级别"><a href="#自定义绘制知识的四个级别" class="headerlink" title="自定义绘制知识的四个级别"></a>自定义绘制知识的四个级别</h2><ol>
<li>Canvas 的 drawXXX () 系列方法及 <code>Paint</code> 最常见的使用 <code>Canvas.drawXXX()</code> 是自定义绘制最基本的操作。配合上 <code>Paint</code> 的一些常见方法来对绘制内容的颜色和风格进行简单的配置，就能够应付大部分的绘制需求。</li>
<li>Paint</li>
<li>Canvas 对绘制的辅助 —— 范围裁切和几何变换。</li>
<li>使用不同的绘制方法来控制绘制顺序</li>
</ol>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h2><p>提前创建好 <code>Paint</code> 对象，重写 <code>onDraw()，把绘制代码写在</code> onDraw ()` 里面，就是自定义绘制最基本的实现。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paint = Paint()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> {</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">    <span class="comment">// 绘制一个圆</span></span><br><span class="line">    canvas.drawCircle(<span class="number">300F</span>, <span class="number">300F</span>, <span class="number">200F</span>, paint)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Canvas-drawXXX-和-Paint-基础"><a href="#Canvas-drawXXX-和-Paint-基础" class="headerlink" title="Canvas.drawXXX() 和 Paint 基础"></a>Canvas.drawXXX () 和 Paint 基础</h2><p>在 Android 里，每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。</p>
<p><code>Paint.setColor(int color)</code> 是 <code>Paint</code> 最常用的方法之一，用来设置绘制内容的颜色。</p>
<p><code>Paint.setStyle(Paint.Style.STROKE)</code> 把绘制模式改为画线模式。<code>Style</code>具体来说有三种：<code>FILL</code>,<code>STROKE</code> 和 <code>FILL_AND_STROKE</code>。<code>FILL</code> 是填充模式，<code>STROKE</code> 是画线模式（即勾边模式），<code>FILL_AND_STROKE</code> 是两种模式一并使用：既画线又填充。它的默认值是 <code>FILL</code>，填充模式。</p>
<p>在 <code>STROKE</code> 和 <code>FILL_AND_STROKE</code> 下，还可以使用 <code>Paint.setStrokeWidth(float width)</code> 来设置线条的宽度。</p>
<p>在绘制的时候，往往需要开启抗锯齿来让图形和文字的边缘更加平滑。只要在实例化 <code>Paint</code> 的时候加上一个 <code>ANTI_ALIAS_FLAG</code> 参数就行，也可以使用 <code>Paint.setAntiAlias(boolean aa)</code> 来动态开关抗锯齿。</p>
<p>通过 <code>Paint.setTextSize(textSize)</code>，可以设置文字的大小。</p>
<h3 id="drawColor-ColorInt-int-color-颜色填充"><a href="#drawColor-ColorInt-int-color-颜色填充" class="headerlink" title="drawColor(@ColorInt int color) 颜色填充"></a>drawColor (@ColorInt int color) 颜色填充</h3><p>这是最基本的 <code>drawXXX()</code> 方法：在整个绘制区域统一涂上指定的颜色。</p>
<p>例如 <code>drawColor(Color.BLACK)</code> 会把整个区域染成纯黑色，覆盖掉原有内容；<code>drawColor(Color.parse("#88880000")</code> 会在原有的绘制效果上加一层半透明的红色遮罩。</p>
<p>类似的方法还有 <code>drawRGB(int r, int g, int b)</code> 和 <code>drawARGB(int a, int r, int g, int b)</code>，它们和 <code>drawColor(color)</code> 只是使用方式不同，作用都是一样的。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line">canvas.drawColor(Color.BLACK)</span><br><span class="line">canvas.drawColor(Color.parseColor(<span class="string">"#88880000"</span>))</span><br><span class="line">canvas.drawRGB(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br><span class="line">canvas.drawARGB(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版</p>
<h3 id="drawCircle-float-centerX-float-centerY-float-radius-Paint-paint-画圆"><a href="#drawCircle-float-centerX-float-centerY-float-radius-Paint-paint-画圆" class="headerlink" title="drawCircle(float centerX, float centerY, float radius, Paint paint) 画圆"></a>drawCircle (float centerX, float centerY, float radius, Paint paint) 画圆</h3><p>前两个参数 <code>centerX</code> <code>centerY</code> 是圆心的坐标，第三个参数 <code>radius</code> 是圆的半径，单位都是像素，它们共同构成了这个圆的基本信息；第四个参数 <code>paint</code> 提供基本信息之外的所有风格信息，例如颜色、线条粗细、阴影等。</p>
<h3 id="drawRect-float-left-float-top-float-right-float-bottom-Paint-paint-画矩形"><a href="#drawRect-float-left-float-top-float-right-float-bottom-Paint-paint-画矩形" class="headerlink" title="drawRect(float left, float top, float right, float bottom, Paint paint) 画矩形"></a>drawRect (float left, float top, float right, float bottom, Paint paint) 画矩形</h3><p><code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是矩形四条边的坐标。<br>另外，它还有两个重载方法 <code>drawRect(RectF rect, Paint paint)</code> 和 <code>drawRect(Rect rect, Paint paint)</code>，让你可以直接填写 <code>RectF</code> 或 <code>Rect</code> 对象来绘制矩形。</p>
<h3 id="drawPoint-float-x-float-y-Paint-paint-画点"><a href="#drawPoint-float-x-float-y-Paint-paint-画点" class="headerlink" title="drawPoint(float x, float y, Paint paint) 画点"></a>drawPoint (float x, float y, Paint paint) 画点</h3><p><code>x</code> 和 <code>y</code> 是点的坐标。点的大小可以通过 <code>paint.setStrokeWidth(width)</code> 来设置；点的形状可以通过 <code>paint.setStrokeCap(cap)</code> 来设置：<code>ROUND</code> 画出来是圆形的点，<code>SQUARE</code> 或 <code>BUTT</code> 画出来是方形的点。</p>
<div class="note warning"><p><code>Paint.setStrokeCap(cap)</code> 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (<code>ROUND</code>)、平头 (<code>BUTT</code>) 和方头 (<code>SQUARE</code>) 三种。</p>
</div>

<h3 id="drawPoints-float-pts-int-offset-int-count-Paint-paint-drawPoints-float-pts-Paint-paint-画点（批量）"><a href="#drawPoints-float-pts-int-offset-int-count-Paint-paint-drawPoints-float-pts-Paint-paint-画点（批量）" class="headerlink" title="drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint) 画点（批量）"></a>drawPoints (float [] pts, int offset, int count, Paint paint) /drawPoints (float [] pts, Paint paint) 画点（批量）</h3><p>同样是画点，它和 <code>drawPoint()</code> 的区别是可以画多个点。<code>pts</code> 这个数组是点的坐标，每两个成一对；<code>offset</code> 表示跳过数组的前几个数再开始记坐标；<code>count</code> 表示一共要绘制几个点。</p>
<h3 id="drawOval-float-left-float-top-float-right-float-bottom-Paint-paint-画椭圆"><a href="#drawOval-float-left-float-top-float-right-float-bottom-Paint-paint-画椭圆" class="headerlink" title="drawOval(float left, float top, float right, float bottom, Paint paint) 画椭圆"></a>drawOval (float left, float top, float right, float bottom, Paint paint) 画椭圆</h3><p>只能绘制横着的或者竖着的椭圆，不能绘制斜的（斜的倒是也可以，但不是直接使用 <code>drawOval()</code>，而是配合几何变换）。<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是这个椭圆的左、上、右、下四个边界点的坐标。另外，它还有一个重载方法 <code>drawOval(RectF rect, Paint paint)</code>，让你可以直接填写 <code>RectF</code> 来绘制椭圆。</p>
<h3 id="drawLine-float-startX-float-startY-float-stopX-float-stopY-Paint-paint-画线"><a href="#drawLine-float-startX-float-startY-float-stopX-float-stopY-Paint-paint-画线" class="headerlink" title="drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 画线"></a>drawLine (float startX, float startY, float stopX, float stopY, Paint paint) 画线</h3><p><code>startX</code>,<code>startY</code>,<code>stopX</code>,<code>stopY</code> 分别是线的起点和终点坐标。</p>
<div class="note warning"><p>由于直线不是封闭图形，所以 <code>setStyle(style)</code> 对直线没有影响。</p>
</div>

<h3 id="drawLines-float-pts-int-offset-int-count-Paint-paint-drawLines-float-pts-Paint-paint-画线（批量）"><a href="#drawLines-float-pts-int-offset-int-count-Paint-paint-drawLines-float-pts-Paint-paint-画线（批量）" class="headerlink" title="drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 画线（批量）"></a>drawLines (float [] pts, int offset, int count, Paint paint) /drawLines (float [] pts, Paint paint) 画线（批量）</h3><p><code>drawLines()</code> 是 <code>drawLine()</code> 的复数版。</p>
<h3 id="drawRoundRect-float-left-float-top-float-right-float-bottom-float-rx-float-ry-Paint-paint-画圆角矩形"><a href="#drawRoundRect-float-left-float-top-float-right-float-bottom-float-rx-float-ry-Paint-paint-画圆角矩形" class="headerlink" title="drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) 画圆角矩形"></a>drawRoundRect (float left, float top, float right, float bottom, float rx, float ry, Paint paint) 画圆角矩形</h3><p><code>left</code>,<code>top</code>,<code>right</code>,<code>bottom</code> 是四条边的坐标，<code>rx</code> 和 <code>ry</code> 是圆角的横向半径和纵向半径。另外，它还有一个重载方法 <code>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</code>，可以直接填写 <code>RectF</code> 来绘制圆角矩形。</p>
<h3 id="drawArc-float-left-float-top-float-right-float-bottom-float-startAngle-float-sweepAngle-boolean-useCenter-Paint-paint-绘制弧形或扇形"><a href="#drawArc-float-left-float-top-float-right-float-bottom-float-startAngle-float-sweepAngle-boolean-useCenter-Paint-paint-绘制弧形或扇形" class="headerlink" title="drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 绘制弧形或扇形"></a>drawArc (float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 绘制弧形或扇形</h3><p><code>drawArc()</code> 是使用一个椭圆来描述弧形的。<code>left</code>,<code>top</code>,<code>right</code>,<code>bottom</code> 描述的是这个弧形所在的椭圆；<code>startAngle</code> 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），<code>sweepAngle</code> 是弧形划过的角度；<code>useCenter</code> 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。</p>
<h3 id="drawPath-Path-path-Paint-paint-画自定义图形"><a href="#drawPath-Path-path-Paint-paint-画自定义图形" class="headerlink" title="drawPath(Path path, Paint paint) 画自定义图形"></a>drawPath (Path path, Paint paint) 画自定义图形</h3><p><code>drawPath(path)</code> 这个方法是通过描述路径的方式来绘制图形的，它的 <code>path</code> 参数就是用来描述图形路径的对象。path <code>的类型是</code> Path`。</p>
<p><code>Path</code> 可以描述直线、二次曲线、三次曲线、圆、椭圆、弧形、矩形、圆角矩形。把这些图形结合起来，就可以描述出很多复杂的图形。</p>
<p><code>Path</code> 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。</p>
<h4 id="Path-方法第一类：直接描述路径"><a href="#Path-方法第一类：直接描述路径" class="headerlink" title="Path 方法第一类：直接描述路径"></a>Path 方法第一类：直接描述路径</h4><h5 id="第一组：-addXxx-——添加子图形"><a href="#第一组：-addXxx-——添加子图形" class="headerlink" title="第一组： addXxx() ——添加子图形"></a>第一组： addXxx () —— 添加子图形</h5><ul>
<li><p>addCircle (float x, float y, float radius, Direction dir) 添加圆</p>
<p>  <code>x</code>,<code>y</code>,<code>radius</code> 这三个参数是圆的基本信息，最后一个参数 <code>dir</code> 是画圆的路径的方向。</p>
  <div class="note warning"><p>路径方向有两种：顺时针 (<code>CW</code> clockwise) 和逆时针 (<code>CCW</code> counter-clockwise) 。对于普通情况，这个参数填 <code>CW</code> 还是填 <code>CCW</code> 没有影响。它只是在需要填充图形 (<code>Paint.Style</code> 为 <code>FILL</code> 或 <code>FILL_AND_STROKE</code>) ，并且图形出现自相交时，用于判断填充范围的。</p>
</div>

<p>  在用 <code>addCircle()</code> 为 <code>Path</code> 中新增一个圆之后，调用 <code>canvas.drawPath(path,paint)</code>，就能画一个圆出来。<code>drawPath()</code> 一般是在绘制组合图形时才会用到。</p>
</li>
<li><p>ddOval (float left, float top, float right, float bottom, Direction dir) /addOval (RectF oval, Direction dir) 添加椭圆</p>
</li>
<li><p>addRect (float left, float top, float right, float bottom, Direction dir) /addRect (RectF rect, Direction dir) 添加矩形</p>
</li>
<li><p>addRoundRect (RectF rect, float rx, float ry, Direction dir) /addRoundRect (float left, float top, float right, float bottom, float rx, float ry, Direction dir) /addRoundRect (RectF rect, float [] radii, Direction dir) /addRoundRect (float left, float top, float right, float bottom, float [] radii, Direction dir) 添加圆角矩形</p>
</li>
<li><p>addPath (Path path) 添加另一个 Path</p>
</li>
</ul>
<h5 id="第二组：xxxTo-——画线（直线或曲线）"><a href="#第二组：xxxTo-——画线（直线或曲线）" class="headerlink" title="第二组：xxxTo() ——画线（直线或曲线）"></a>第二组：xxxTo () —— 画线（直线或曲线）</h5><ul>
<li><p>lineTo (float x, float y) /rLineTo (float x, float y) 画直线</p>
<p>  从<strong>当前位置</strong>向目标位置画一条直线，<code>x</code> 和 <code>y</code> 是目标位置的坐标。这两个方法的区别是，<code>lineTo(x, y)</code> 的参数是<strong>绝对坐标</strong>，而 <code>rLineTo(x, y)</code> 的参数是相对当前位置的<strong>相对坐标</strong>（前缀 <code>r</code> 指的就是 <code>relatively</code>「相对地」)。</p>
  <div class="note warning"><p><strong>当前位置</strong>：所谓当前位置，即最后一次调用画 <code>Path</code> 的方法的终点位置。初始值为原点 (0, 0)。</p>
</div>
</li>
<li><p>quadTo (float x1, float y1, float x2, float y2) /rQuadTo (float dx1, float dy1, float dx2, float dy2) 画二次贝塞尔曲线</p>
<p>  这条二次贝塞尔曲线的起点就是当前位置，而参数中的 <code>x1</code>,<code>y1</code> 和 <code>x2</code>,<code>y2</code> 则分别是控制点和终点的坐标。和 <code>rLineTo(x, y)</code> 同理，<code>rQuadTo(dx1, dy1, dx2, dy2)</code> 的参数也是相对坐标。</p>
</li>
<li><p>cubicTo (float x1, float y1, float x2, float y2, float x3, float y3) /rCubicTo (float x1, float y1, float x2, float y2, float x3, float y3) 画三次贝塞尔曲线</p>
</li>
<li><p>moveTo (float x, float y) /rMoveTo (float x, float y) 移动到目标位置</p>
<p>  不论是直线还是贝塞尔曲线，都是以当前位置作为起点，而不能指定起点。可以通过 <code>moveTo(x, y)</code> 或 <code>rMoveTo()</code> 来改变当前位置，从而间接地设置这些方法的起点。</p>
<p>  <code>moveTo(x, y)</code> 虽然不添加图形，但它会设置图形的起点，所以它是非常重要的一个辅助方法。</p>
</li>
<li><p>arcTo (RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) /arcTo (float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) /arcTo (RectF oval, float startAngle, float sweepAngle) 画弧形</p>
<p>  <code>forceMoveTo</code> 参数的意思是，绘制是要「抬一下笔移动过去」，还是「直接拖着笔过去」，区别在于是否留下移动的痕迹。<code>true</code> 不留痕迹。</p>
</li>
<li><p>addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle)</p>
<p>  <code>addArc()</code> 只是一个直接使用了 <code>forceMoveTo = true</code> 的简化版 <code>arcTo()</code>。</p>
</li>
<li><p>close () 封闭当前子图形</p>
<p>  它的作用是把当前的子图形封闭，即由当前位置向当前子图形的起点绘制一条直线。<code>close()</code> 和 <code>lineTo(起点坐标)</code> 是完全等价的。</p>
  <div class="note warning"><p>「子图形」：官方文档里叫做 <code>contour</code>。所谓「子图形」，指的就是一次不间断的连线。一个 <code>Path</code> 可以包含多个子图形。当使用第一组方法，即 <code>addCircle()</code> <code>addRect()</code> 等方法的时候，每一次方法调用都是新增了一个独立的子图形；而如果使用第二组方法，即 <code>lineTo()</code> <code>arcTo()</code> 等方法的时候，则是每一次断线（即每一次「抬笔」），都标志着一个子图形的结束，以及一个新的子图形的开始。</p>
</div>
  <div class="note warning"><p>另外，不是所有的子图形都需要使用 <code>close()</code> 来封闭。当需要填充图形时（即 <code>Paint.Style</code> 为 <code>FILL</code> 或 <code>FILL_AND_STROKE</code>）,<code>Path</code> 会自动封闭子图形。</p>
</div></li>
</ul>
<h4 id="Path方法第二类：辅助的设置或计算"><a href="#Path方法第二类：辅助的设置或计算" class="headerlink" title="Path方法第二类：辅助的设置或计算"></a>Path 方法第二类：辅助的设置或计算</h4><p>这类方法的使用场景比较少。</p>
<h5 id="Path-setFillType-Path-FillType-ft-设置填充方式"><a href="#Path-setFillType-Path-FillType-ft-设置填充方式" class="headerlink" title="Path.setFillType(Path.FillType ft)设置填充方式"></a>Path.setFillType (Path.FillType ft) 设置填充方式</h5><p><code>Path.setFillType(fillType)</code> 是用来设置图形自相交时的填充算法的，<code>FillType</code> 的取值有四个：</p>
<ul>
<li><code>EVEN_ODD</code></li>
<li><code>WINDING</code> （默认值）</li>
<li><code>INVERSE_EVEN_ODD</code></li>
<li><code>INVERSE_WINDING</code></li>
</ul>
<p>其中后面的两个带有 <code>INVERSE_</code> 前缀的，只是前两个的反色版本。</p>
<p>简单粗暴版的总结，<code>WINDING</code> 是「全填充」，而 <code>EVEN_ODD</code> 是「交叉填充」：</p>
<p><img src="https://img.mumo.fun/2022/22-5.png" alt="图 5">  </p>
<p>之所以叫「简单粗暴版」，是因为这些只是通常情形下的效果</p>
<h5 id="EVEN-ODD和WINDING的原理"><a href="#EVEN-ODD和WINDING的原理" class="headerlink" title="EVEN_ODD和WINDING的原理"></a>EVEN_ODD 和 WINDING 的原理</h5><ul>
<li><p>EVEN_ODD</p>
<p>  即 even-odd rule（奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。以左右相交的双圆为例：</p>
<p>  <img src="https://img.mumo.fun/2022/22-1.png" alt="图 1">  </p>
<p>  从上图可以看出，射线每穿过图形中的一条线，内外状态就发生一次切换，这就是为什么 EVEN_ODD 是一个「交叉填充」的模式。</p>
</li>
<li><p>WINDING</p>
<p>  即 non-zero winding rule （非零环绕数原则）：首先，它需要你图形中的所有线条都是有绘制方向的：</p>
<p>  <img src="https://img.mumo.fun/2022/22-2.jpg" alt="图 2"> </p>
<p>  然后，同样是从平面中的点向任意方向射出一条射线，但计算规则不一样：以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。</p>
<p>  <img src="https://img.mumo.fun/2022/22-3.jpg" alt="图 3"> </p>
<p>  如果你所有的图形都用相同的方向来绘制，那么 <code>WINDING</code> 确实是一个「全填充」的规则；但如果使用不同的方向来绘制图形，结果就不一样了。</p>
  <details class="note "><summary><p>waring</p>
</summary>
<p>图形的方向：对于添加子图形类方法（如 <code>Path.addCircle()</code> <code>Path.addRect()</code>）的方向，由方法的 <code>dir</code> 参数来控制；而对于画线类的方法（如 <code>Path.lineTo()</code> <code>Path.arcTo()</code>），线的方向就是图形的方向。</p>

</details></li>
</ul>
<p>完整版的 <code>EVEN_ODD</code> 和 <code>WINDING</code> 的效果应该是这样的：</p>
<p><img src="https://img.mumo.fun/2022/22-4.png" alt="图 4">  </p>
<h3 id="drawBitmap-Bitmap-bitmap-float-left-float-top-Paint-paint-画-Bitmap"><a href="#drawBitmap-Bitmap-bitmap-float-left-float-top-Paint-paint-画-Bitmap" class="headerlink" title="drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap"></a>drawBitmap (Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap</h3><p>绘制 <code>Bitmap</code> 对象，也就是把这个 <code>Bitmap</code> 中的像素内容贴过来。其中 <code>left</code> 和 <code>top</code> 是要把 <code>bitmap</code> 绘制到的位置坐标。</p>
<p>它的重载方法：</p>
<p><code>drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)</code> /<br><code>drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)</code> /<br><code>drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)</code></p>
<details class="note "><summary><p>waring</p>
</summary>
<p><code>drawBitmap</code> 还有一个兄弟方法 <code>drawBitmapMesh()</code>，可以绘制具有网格拉伸效果的 Bitmap。<code>drawBitmapMesh()</code> 的使用场景较少。</p>

</details>

<h3 id="drawText-String-text-float-x-float-y-Paint-paint-绘制文字"><a href="#drawText-String-text-float-x-float-y-Paint-paint-绘制文字" class="headerlink" title="drawText(String text, float x, float y, Paint paint) 绘制文字"></a>drawText (String text, float x, float y, Paint paint) 绘制文字</h3><p><code>drawText()</code> 这个方法就是用来绘制文字的。参数 <code>text</code> 是用来绘制的字符串，<code>x</code> 和 <code>y</code> 是绘制的起点坐标。</p>
<h1 id="Paint详解"><a href="#Paint详解" class="headerlink" title="Paint详解"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-2/">Paint 详解</a></h1><h1 id="drawText-文字的绘制"><a href="#drawText-文字的绘制" class="headerlink" title="drawText()文字的绘制"></a><pangu> </pangu><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-3/">drawText () 文字的绘制</a></h1><h1 id="Canvas对绘制的辅助"><a href="#Canvas对绘制的辅助" class="headerlink" title="Canvas对绘制的辅助"></a><pangu> </pangu><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-4/">Canvas 对绘制的辅助</a></h1><h1 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-5/">绘制顺序</a></h1><h2 id="super-onDraw-前or后"><a href="#super-onDraw-前or后" class="headerlink" title="super.onDraw()前or后"></a>super.onDraw () 前 or 后</h2><h3 id="写在super-onDraw-的下面"><a href="#写在super-onDraw-的下面" class="headerlink" title="写在super.onDraw()的下面"></a>写在 super.onDraw () 的下面</h3><p>把绘制代码写在 <code>super.onDraw()</code> 的下面，由于绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。</p>
<h3 id="写在super-onDraw-的上面"><a href="#写在super-onDraw-的上面" class="headerlink" title="写在super.onDraw()的上面"></a>写在 super.onDraw () 的上面</h3><p>如果把绘制代码写在 <code>super.onDraw()</code> 的上面，由于绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。</p>
<h2 id="dispatchDraw-：绘制子View的方法"><a href="#dispatchDraw-：绘制子View的方法" class="headerlink" title="dispatchDraw()：绘制子View的方法"></a>dispatchDraw ()：绘制子 View 的方法</h2><p>在绘制过程中，每个 View 和 ViewGroup 都会先调用 <code>onDraw()</code> 方法来绘制主体，再调用 <code>dispatchDraw()</code> 方法来绘制子 View。</p>
<h3 id="写在-super-dispatchDraw-的下面"><a href="#写在-super-dispatchDraw-的下面" class="headerlink" title="写在 super.dispatchDraw() 的下面"></a>写在 super.dispatchDraw () 的下面</h3><p>只要重写 dispatchDraw ()，并在 super.dispatchDraw () 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。</p>
<h3 id="写在super-dispatchDraw-的上面"><a href="#写在super-dispatchDraw-的上面" class="headerlink" title="写在super.dispatchDraw()的上面"></a>写在 super.dispatchDraw () 的上面</h3><p>把绘制代码写在 <code>super.dispatchDraw()</code> 的上面，这段绘制就会在 <code>onDraw()</code> 之后、<code>super.dispatchDraw()</code> 之前发生，也就是绘制内容会出现在主体内容和子 View 之间。其实和前面重写 <code>onDraw()</code> 并把绘制代码写在 <code>super.onDraw()</code> 之后的做法，效果是一样的。</p>
<h2 id="绘制过程简述"><a href="#绘制过程简述" class="headerlink" title="绘制过程简述"></a>绘制过程简述</h2><p>一个完整的绘制过程会依次绘制以下几个内容：</p>
<ul>
<li>背景</li>
<li>主体（<code>onDraw()</code>）</li>
<li>子 View（<code>dispatchDraw()</code>）</li>
<li>滑动边缘渐变和滑动条</li>
<li>前景</li>
</ul>
<p>一般来说，一个 View（或 ViewGroup）的绘制不会这几项全都包含，但必然逃不出这几项，并且一定会严格遵守这个顺序。</p>
<p>背景的绘制发生在 <code>drawBackground()</code> 的方法里，但这个方法是 <code>private</code> 的，不能重写，只能用自带的 API 去设置（xml 布局文件的 <code>android:background</code> 属性以及 Java 代码的 <code>View.setBackgroundXxx()</code> 方法），而不能自定义绘制。</p>
<p>滑动边缘渐变和滑动条以及前景，这两部分被合在一起放在 <code>onDrawForeground()</code> 方法里，这个方法是可以重写的。</p>
<p>滑动边缘渐变和滑动条可以通过 xml 的 <code>android:scrollbarXXX</code> 系列属性或 Java 代码的 <code>View.setXXXScrollbarXXX()</code> 系列方法来设置；前景可以通过 xml 的 <code>android:foreground</code> 属性或 Java 代码的 <code>View.setForeground()</code> 方法来设置。而重写 <code>onDrawForeground()</code> 方法，并在它的 <code>super.onDrawForeground()</code> 方法的上面或下面插入绘制代码，则可以控制绘制内容和滑动边缘渐变、滑动条以及前景的遮盖关系。</p>
<h2 id="onDrawForeground-（API-23引入）"><a href="#onDrawForeground-（API-23引入）" class="headerlink" title="onDrawForeground()（API 23引入）"></a>onDrawForeground ()（API 23 引入）</h2><p>在 <code>onDrawForeground()</code> 中，会依次绘制滑动边缘渐变、滑动条和前景。</p>
<h3 id="写在super-onDrawForeground-的下面"><a href="#写在super-onDrawForeground-的下面" class="headerlink" title="写在super.onDrawForeground()的下面"></a>写在 super.onDrawForeground () 的下面</h3><p>如果绘制代码写在 <code>super.onDrawForeground()</code> 的下面，绘制代码会在滑动边缘渐变、滑动条和前景之后被执行，那么绘制内容将会盖住滑动边缘渐变、滑动条和前景。</p>
<h3 id="写在super-onDrawForeground-的上面"><a href="#写在super-onDrawForeground-的上面" class="headerlink" title="写在super.onDrawForeground()的上面"></a>写在 super.onDrawForeground () 的上面</h3><p>如果你把绘制代码写在了 <code>super.onDrawForeground()</code> 的上面，绘制内容就会在 <code>dispatchDraw()</code> 和 <code>super.onDrawForeground()</code> 之间执行，那么绘制内容会盖住子 View，但被滑动边缘渐变、滑动条以及前景盖住。</p>
<p>这种写法，和重写 <code>dispatchDraw()</code> 并把绘制代码写在 <code>super.dispatchDraw()</code> 的下面的效果是一样的：绘制内容都会盖住子 View，但被滑动边缘渐变、滑动条以及前景盖住。</p>
<h2 id="draw-总调度方法"><a href="#draw-总调度方法" class="headerlink" title="draw()总调度方法"></a>draw () 总调度方法</h2><p>draw () 是绘制过程的总调度方法。一个 View 的整个绘制过程都发生在 <code>draw()</code> 方法里。</p>
<h3 id="写在super-draw-的下面"><a href="#写在super-draw-的下面" class="headerlink" title="写在super.draw()的下面"></a>写在 super.draw () 的下面</h3><p>由于 <code>draw()</code> 是总调度方法，所以如果把绘制代码写在 <code>super.draw()</code> 的下面，那么这段代码会在其他所有绘制完成之后再执行，也就是说，它的绘制内容会盖住其他的所有绘制内容。</p>
<h3 id="写在super-draw-的上面"><a href="#写在super-draw-的上面" class="headerlink" title="写在super.draw()的上面"></a>写在 super.draw () 的上面</h3><p>由于 <code>draw()</code> 是总调度方法，所以如果把绘制代码写在 <code>super.draw()</code> 的上面，那么这段代码会在其他所有绘制之前被执行，所以这部分绘制内容会被其他所有的内容盖住，包括背景。</p>
<p><img src="https://img.mumo.fun/2022/22-6.jpg" alt="图 1">  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p>出于效率的考虑，ViewGroup 默认会绕过 <code>draw()</code> 方法，换而直接执行 <code>dispatchDraw()</code>，以此来简化绘制流程。所以如果你自定义了某个 <code>ViewGroup</code> 的子类（比如 <code>LinearLayout</code>）并且需要在它的除 <code>dispatchDraw()</code> 以外的任何一个绘制方法内绘制内容，你可能会需要调用 <code>View.setWillNotDraw(false)</code> 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 <code>ViewGroup</code> 是已经调用过 <code>setWillNotDraw(false)</code> 了的，例如 <code>ScrollView</code>）。</p>
</li>
<li><p>有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 <code>onDraw()</code> 里，也可以写在其他绘制方法里，那么优先写在 <code>onDraw()</code>，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 <code>onDraw()</code> 的重复执行，以提升开发效率。享受这种优化的只有 <code>onDraw()</code> 一个方法。</p>
</li>
</ol>
<p><img src="https://img.mumo.fun/2022/22-7.png" alt="图 2">  </p>
<h1 id="属性动画Property-Animation上手"><a href="#属性动画Property-Animation上手" class="headerlink" title="属性动画Property Animation上手"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-6/">属性动画 Property Animation 上手</a></h1><h1 id="属性动画Property-Animation进阶"><a href="#属性动画Property-Animation进阶" class="headerlink" title="属性动画Property Animation进阶"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-7/">属性动画 Property Animation 进阶</a></h1><h1 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-1-8/">硬件加速</a></h1><h1 id="布局基础"><a href="#布局基础" class="headerlink" title="布局基础"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-2-1/">布局基础</a></h1><h2 id="布局过程的含义"><a href="#布局过程的含义" class="headerlink" title="布局过程的含义"></a>布局过程的含义</h2><p>布局过程，就是程序在运行时利用布局文件的代码来计算出实际尺寸的过程。</p>
<h2 id="布局过程的工作内容"><a href="#布局过程的工作内容" class="headerlink" title="布局过程的工作内容"></a>布局过程的工作内容</h2><p>两个阶段：测量阶段和布局阶段。</p>
<ul>
<li>测量阶段：从上到下递归地调用每个 View 或者 ViewGroup 的 <code>measure()</code> 方法，测量他们的尺寸并计算它们的位置；</li>
<li>布局阶段：从上到下递归地调用每个 View 或者 ViewGroup 的 <code>layout()</code> 方法，把测得的它们的尺寸和位置赋值给它们。</li>
</ul>
<h2 id="View或ViewGroup的布局过程"><a href="#View或ViewGroup的布局过程" class="headerlink" title="View或ViewGroup的布局过程"></a>View 或 ViewGroup 的布局过程</h2><ol>
<li><p>测量阶段，<code>measure()</code> 方法被父 View 调用，在 <code>measure()</code> 中做一些准备和优化工作后，调用 <code>onMeasure()</code> 来进行实际的自我测量。<code>onMeasure()</code> 做的事，View 和 ViewGroup 不一样：</p>
<ol>
<li><p>View：View 在 <code>onMeasure()</code> 中会计算出自己的尺寸然后保存；</p>
</li>
<li><p>ViewGroup：ViewGroup 在 <code>onMeasure()</code> 中会调用所有子 View 的 <code>measure()</code> 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置（实际上 99.99% 的父 View 都会使用子 View 给出的期望尺寸来作为实际尺寸）然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存；</p>
</li>
</ol>
</li>
<li><p>布局阶段，<code>layout()</code> 方法被父 View 调用，在 <code>layout()</code> 中它会保存父 View 传进来的自己的位置和尺寸，并且调用 <code>onLayout()</code> 来进行实际的内部布局。<code>onLayout()</code> 做的事，View 和 ViewGroup 也不一样：</p>
<ol>
<li><p>View：由于没有子 View，所以 View 的 <code>onLayout()</code> 什么也不做。</p>
</li>
<li><p>ViewGroup：ViewGroup 在 <code>onLayout()</code> 中会调用自己的所有子 View 的 <code>layout()</code> 方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。</p>
</li>
</ol>
</li>
</ol>
<h2 id="布局过程自定义的方式"><a href="#布局过程自定义的方式" class="headerlink" title="布局过程自定义的方式"></a>布局过程自定义的方式</h2><p>三类：</p>
<ol>
<li><p>重写 <code>onMeasure()</code> 来修改已有的 View 的尺寸：</p>
<ol>
<li><p>重写 <code>onMeasure()</code> 方法，并在里面调用 <code>super.onMeasure()</code>，触发原有的自我测量；</p>
</li>
<li><p>在 <code>super.onMeasure()</code> 的下面用 <code>getMeasuredWidth()</code> 和 <code>getMeasuredHeight()</code> 来获取到之前的测量结果，并使用自己的算法，根据测量结果计算出新的结果；</p>
</li>
<li><p>调用 <code>setMeasuredDimension()</code> 来保存新的结果。</p>
</li>
</ol>
</li>
<li><p>重写 <code>onMeasure()</code> 来全新定制自定义 View 的尺寸；</p>
</li>
<li><p>重写 <code>onMeasure()</code> 和 <code>onLayout()</code> 来全新定制自定义 ViewGroup 的内部布局。</p>
</li>
</ol>
<h1 id="全新定义View的尺寸"><a href="#全新定义View的尺寸" class="headerlink" title="全新定义View的尺寸"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-2-2/">全新定义 View 的尺寸</a></h1><h2 id="全新定制尺寸和修改尺寸的最重要区别"><a href="#全新定制尺寸和修改尺寸的最重要区别" class="headerlink" title="全新定制尺寸和修改尺寸的最重要区别"></a>全新定制尺寸和修改尺寸的最重要区别</h2><p>需要在计算的同时，保证计算结果满足父 View 给出的的尺寸限制</p>
<h2 id="父View的尺寸限制"><a href="#父View的尺寸限制" class="headerlink" title="父View的尺寸限制"></a>父 View 的尺寸限制</h2><ol>
<li><p>由来：开发者的要求（布局文件中 <code>layout_</code>打头的属性）经过父 View 处理计算后的更精确的要求；</p>
</li>
<li><p>限制的分类：</p>
<ol>
<li><p><code>UNSPECIFIED</code>：不限制</p>
</li>
<li><p><code>AT_MOST</code>：限制上限</p>
</li>
<li><p><code>EXACTLY</code>：限制固定值</p>
</li>
</ol>
</li>
</ol>
<h2 id="全新定义自定义View尺寸的方式"><a href="#全新定义自定义View尺寸的方式" class="headerlink" title="全新定义自定义View尺寸的方式"></a>全新定义自定义 View 尺寸的方式</h2><ol>
<li><p>重新 <code>onMeasure()</code>，并计算出 View 的尺寸；</p>
</li>
<li><p>使用 <code>resolveSize()</code> 来让子 View 的计算结果符合父 View 的限制（当然，如果你想用自己的方式来满足父 View 的限制也行）。</p>
</li>
</ol>
<h1 id="定制Layout的内部布局"><a href="#定制Layout的内部布局" class="headerlink" title="定制Layout的内部布局"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-2-3/">定制 Layout 的内部布局</a></h1><h2 id="定制Layout内部布局的方式"><a href="#定制Layout内部布局的方式" class="headerlink" title="定制Layout内部布局的方式"></a>定制 Layout 内部布局的方式</h2><ol>
<li><p>重写 <code>onMeasure()</code> 来计算内部布局</p>
</li>
<li><p>重写 <code>onLayout()</code> 来摆放子 View</p>
</li>
</ol>
<h2 id="重写onMeasure-的三个步骤："><a href="#重写onMeasure-的三个步骤：" class="headerlink" title="重写onMeasure()的三个步骤："></a>重写 onMeasure () 的三个步骤：</h2><ol>
<li><p>调用每个子 View 的 <code>measure()</code> 来计算子 View 的尺寸</p>
</li>
<li><p>计算子 View 的位置并保存子 View 的位置和尺寸</p>
</li>
<li><p>计算自己的尺寸并用 <code>setMeasuredDimension()</code> 保存</p>
</li>
</ol>
<h2 id="计算子View尺寸的关键"><a href="#计算子View尺寸的关键" class="headerlink" title="计算子View尺寸的关键"></a>计算子 View 尺寸的关键</h2><p>计算子 View 的尺寸，关键在于 <code>measure()</code> 方法的两个参数 —— 也就是子 View 的两个 <code>MeasureSpec</code> 的计算。</p>
<h3 id="子View的MeasureSpec的计算方式："><a href="#子View的MeasureSpec的计算方式：" class="headerlink" title="子View的MeasureSpec的计算方式："></a>子 View 的 MeasureSpec 的计算方式：</h3><ul>
<li><p>结合开发者的要求（xml 中 <code>layout_</code>打头的属性）和自己的可用空间（自己的尺寸上限 - 已用尺寸）</p>
</li>
<li><p>尺寸上限根据自己的 <code>MeasureSpec</code> 中的 mode 而定</p>
<ul>
<li><p>EXACTLY/AT_MOST：尺寸上限为 <code>MeasureSpec</code> 中的 <code>size</code></p>
</li>
<li><p>UNSPECIFIED：尺寸无上限</p>
</li>
</ul>
</li>
</ul>
<h2 id="重写onLayout-的方式"><a href="#重写onLayout-的方式" class="headerlink" title="重写onLayout()的方式"></a>重写 <code>onLayout()</code> 的方式</h2><p>在 <code>onLayout()</code> 里调用每个子 View 的 <code>layout()</code>，让它们保存自己的位置和尺寸。</p>
<h1 id="触摸反馈"><a href="#触摸反馈" class="headerlink" title="触摸反馈"></a><a target="_blank" rel="noopener" href="https://rengwuxian.com/ui-3-1/">触摸反馈</a></h1><p>自定义触摸反馈的关键：</p>
<ol>
<li><p>重写 <code>onTouchEvent()</code>，在里面写上你的触摸反馈算法，并返回 <code>true</code>（关键是 <code>ACTION_DOWN</code> 事件时返回 <code>true</code>）。</p>
</li>
<li><p>如果是会发生触摸冲突的 ViewGroup，还需要重写 <code>onInterceptTouchEvent()</code>，在事件流开始时返回 <code>false</code>，并在确认接管事件流时返回一次 <code>true</code>，以实现对事件的拦截。</p>
</li>
<li><p>当子 View 临时需要阻止父 View 拦截事件流时，可以调用父 View 的 <code>requestDisallowInterceptTouchEvent()</code>，通知父 View 在当前事件流中不再尝试通过 <code>onInterceptTouchEvent()</code> 来拦截。</p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer"><script>
    var elements = document.querySelectorAll('figure');
	for (var i = 0; i < elements.length; i++) {
		var lang = elements[i].getAttribute("class");
		if (lang != null ) {
		lang = lang.substr(10);
		}
		elements[i].setAttribute("data-language", lang);
	}
</script>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Mumo
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://mumo.fun/posts/22/" title="Android 自定义 View">https://mumo.fun/posts/22/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/21/" rel="prev" title="Hexo Next 七牛图床不显示图片的解决方法">
                  <i class="fa fa-chevron-left"></i> Hexo Next 七牛图床不显示图片的解决方法
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>





<style>
        .ss_ad{
            display: block;
            width: 100%;
            text-align: center;
            color: #fff;
            background: #0088CC;
			font-family: Microsoft YaHei;
        }
		a.ss_ad{
			border:0;
			color:#fff;
		}
		a.ss_ad:hover{
				text-decoration:none;
				color:#fff;
		}
</style>
<div class="post-block animated fadeIn" style="margin-top:20px; padding: 0px; background: #0088cc">
<a class="ss_ad" style="font-size:22px" href="https://order.yizhihongxing.network/aff.php?aff=3671" target="_blank">可靠便捷的VPN服务</a>
<a class="ss_ad" style="font-size:15px" href="https://order.yizhihongxing.network/aff.php?aff=3671" target="_blank">100 G 月流量，5台设备可用，一年仅需99元！</a>
</div>
    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mumo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://twikoo-nu-opal.vercel.app/","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

</body>
</html>
